# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

	Команда `cd` является встроенной в оболочку командой

    ```bash
    $ type -a cd
    cd is a shell builtin
    ```

1. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.


    Использование опции `-c(--count)` команды `grep`, которая подавляет стандартный вывод и отображает количество строк файла, в которых найдено совпадение

    `grep -с <some_string> <some_file>`
1. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

    Процесс systemd
    ```bash
    $ ps -p 1
        PID TTY          TIME CMD
          1 ?        00:00:01 systemd
    ```
    А процесс `init` стал символьной ссылкой на процесс `systemd`

	```bash
	$ type -a init
    init is /usr/sbin/init
    init is /sbin/init
    ```
    ```bash
    $ ls -la /usr/sbin/init
    lrwxrwxrwx 1 root root 20 Jul 21 19:00 /usr/sbin/init -> /lib/systemd/systemd
    ```
    ```bash
    $ ls -la /sbin/init
    lrwxrwxrwx 1 root root 20 Jul 21 19:00 /sbin/init -> /lib/systemd/systemd
    ```


1. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

    Исходная сессия терминала
    ```bash
    $ tty
    /dev/pts/0
    ```

    Целевая сессия терминала, на который нужно передать вывод ошибок с команды `ls`
    ```bash
    $ tty
    /dev/pts/1
    ```

   На целевой сессии запускаем команду `ls` для просмотра содержимого несуществующего каталога и перенаправляем ошибки на целевую сессию терминала (`2>/dev/pts/1`)

   ```bash
   $ ls -al /tmp/non_exist_folder 2>/dev/pts/1
   $
   ```

   На целевой сессии терминала ожидаемо получаем вывод ошибки команды, выполненной на исходной сессии терминала
   ```bash
   ls: cannot access '/tmp/non_exist_folder': No such file or directory
   ```
1. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

	Да, это возможно.

    Например, следующим образом:
    ```bash
    $ cat in.txt
    11
    22
    33
    ```
    ```bash
    $ grep 11 < in.txt > out.txt
    ```
    ```bash
    $ cat out.txt
    11
    ```
1. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

   Вывести получится, но наблюдать выводимые данные - нет

   Только можно увидеть эти данные на эммуляторе TTY
   ```bash
   ls -al /tmp/ > /dev/tty2
   ```
   На эммуляторе TTY отобразится содержимоое каталога /tmp
1. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

     `bash 5>&1`

    Файловый дескриптор с номером 5 для текущего bash-процесcа будет перенаправлен на стандартный вывод этого же процесса

    ```bash
    $ ls -l /proc/$$/fd/
    total 0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:21 0 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:21 1 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:21 2 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:47 255 -> /dev/pts/0
    ```

    ```bash
    $ ls -l /proc/$$/fd/
    total 0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:47 0 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:47 1 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:47 2 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:47 255 -> /dev/pts/0
    lrwx------ 1 vagrant vagrant 64 Aug 24 12:47 5 -> /dev/pts/0
    ```

    При выполнении команды  `echo netology > /proc/$$/fd/5` происходит вывод результата работы команды на терминал т.к.
    в команде выполняется перенаправление стандартного вывода в тот же самый файловый дескриптор(в нашем случае в файловый дескриптор с номером 5)
    который в свою очередь ранее был перенаправлен на стандартный вывод (в файловый дескриптор 1)
    ```bash
    $ echo netology > /proc/$$/fd/5
    netology
    ```

1. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

   Необходимо перенаправить вывод ошибок в в стандартный вывод `2>&1 для` передачи ошибок на `pipe`, а для сохранения стандартного вывода, перенаправить его на вторую консоль `1>/dev/pts/1`

   Например,подсчитаем количество символов в строке, которая выводится в качестве вывода ошибки

   ```bash
   # cat /tmp/nonexistfile 2>&1 1>/dev/pts/1 | wc -c
   50
   ```

   Посмотрим содержимое этой строки
   ```bash
   # cat /tmp/nonexistfile
   cat: /tmp/nonexistfile: No such file or directory
   ```

   Подсчитаем количетво символов в этой строке
   ```bash
   # echo "cat: /tmp/nonexistfile: No such file or directory" | wc -c
   50
   ```

   т.к. файла не существует, то в стандартный вывод ничего не попадет, т.е. на второй консоле ничего не отобразится

   При выполнении команды, которая имеет стандартный вывод, на второй консоле будет выведен этот стандартный вывод

   Например, на второй консоле будет отображено содержимое каталога `/tmp`
   ```bash
   # ls -al /tmp/ 2>&1 1>/dev/pts/1 | wc -c
   0
   ```

1. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
   ```bash
   $ man 5   proc | grep -A 10 /environ
   ```
   Список переменных, которые были установлены на момент старта текущего процесса (в данном случае процесса оболочки bash)

   Однако, если после своего запуска, процесс изменил свои переменные, то эти изменения не будут отображены в выводе этой команды

   Форматируемый вывод этой команды имеет вид
   ```bash
   cat /proc/$$/environ | tr '\000' '\n'
   ```

   Альтернативными командами для просмотра переменных окружения являются команды

   - `printenv`
   - `env`
1. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

   - `/proc/<PID>/cmdline`
    ```bash
    $ cat /proc/$$/cmdline
    -bash
	```

	В этом файле содержится команда и список аргументов(если они были использованы) для запуска процесса с указанным `<PID>`

	В случае зомби процесса там не содержится ничего

	- `/proc/<PID>/exe`

	В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к исполняемой команде
	```bash
	$ file /proc/$$/exe
    /proc/13600/exe: symbolic link to /usr/bin/bash
    ```

1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

   `SSE4_2`

   ```bash
   $ grep -w sse[0-9] /proc/cpuinfo | head -n 1
   flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall    nx rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx    est tm2 ssse3 cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm cpuid_fault epb pti ssbd    ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms xsaveopt dtherm ida arat pln pts md_clear flush_l1d
   ```
1. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.

    По умолчанию, если просто подключаться по SSH без выполнения команд(`ssh localhost`), то выделяется псевдотерминал т.к. запускается `shell`-сессия

    По умолчанию, если при подключении по SSH выполнять команду(например, `ssh vagrant@localhost 'tty'`), то такой терминал не выделяется

    Решение  - принудительно включить/запросить псевдотерминал `tty` с помощью ключа/параметра `-t` команды ssh
    ```bash
    $ ssh -t localhost 'tty'
    vagrant@localhost's password:
    /dev/pts/4
    Connection to localhost closed.
    ```
1. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

    Reptyr использует системный вызов `ptrace` для подключения к файловым дескриптерам запущенного процесса и перенаправляет их
    , а также изменяет управляющий терминал программы

    На весриях `Ubuntu 10.10+` эта возможность отключена по умолчанию из соображений безопасности

    Поэтому необходимо либо временно либо на постоянно (через редактирование файла `/etc/sysctl.d/10-ptrace.conf`) включить такую возможность

    ```bash
    $ cat /proc/sys/kernel/yama/ptrace_scope
    1
    ```

    Включим временно для выполнения задания:
    ```bash
    $ echo 0 | sudo tee  /proc/sys/kernel/yama/ptrace_scope
    ```

    ```bash
    $ cat /proc/sys/kernel/yama/ptrace_scope
    0
    ```

    На первой консоли запустим процесс,который нужно перенести в Screen на вторую консоль
	```bash
    $ sleep 1h
    ```

    На второй консоли запускаем screen
    ```bash
    $ screen -S test
    ```

    Подключаемся командой `reptyr` к идентифкатору запущенного процесса, который нужно перенести из стандартной SSH-сессии в Screen
    ```bash
    $ reptyr `pgrep sleep`
    ```

    После чего команда продолжит выполняться в скрине уже на новом терминале
    На старром терминале команда будет иметь статус остановлена

    ```bash
    [1]+  Stopped                 sleep 1h
    ```

    Старый терминал теперь можно безопасно(без прерывания выполнения процесса/программы) закрыть

    Более полный вариант работы может иметь вид:

    Перевести процесс в остановленное/замороженное состояние

    Через нажате комбинации клавиш CTRL+Z
    ```bash
    $ sleep 1h
    ^Z
    [1]+  Stopped                 sleep 1h
    ```

    ```bash
    $ jobs
    [1]+  Stopped                 sleep 1h
    ```

    Запустить выполнение остановленного процесса в фоне (background):
    ```bash
    $ bg
    [1]+ sleep 1h &
    ```

    ```bash
    $ jobs
    [1]+  Running                 sleep 1h &
    ```

    Отключитьь процесс от текущей оболочки:

    ```bash
    $ disown sleep
    $
    ```

    ```bash
    $ ps aux | grep [s]leep
    vagrant    17822  0.0  0.0   9828   592 pts/0    S    21:39   0:00 sleep 1h
    ```

    ```bash
    $ pgrep sleep
    17822
    ```

    Подключаемся командой `reptyr` к идентифкатору запущенного процесса, который нужно перенести из стандартной SSH-сессии в screen
    ```bash
    $ reptyr `pgrep sleep`
    ```


1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

   Команда `tee` читает из стандартного потока ввода и записывает в стандартный поток вывода и в файл одновременно

   Команда отработает корректно по причине того, что команда `tee` будет запущена через `sudo` повышая тем самым привиллегии этой команды до  `root`-пользователя, что позволит успешно записать в файл, который доступен на запиcь только для `root`-пользователю

 ---

## Как сдавать задания

Обязательными к выполнению являются задачи без указания звездочки. Их выполнение необходимо для получения зачета и диплома о профессиональной переподготовке.

Задачи со звездочкой (*) являются дополнительными задачами и/или задачами повышенной сложности. Они не являются обязательными к выполнению, но помогут вам глубже понять тему.

Домашнее задание выполните в файле readme.md в github репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.

Также вы можете выполнить задание в [Google Docs](https://docs.google.com/document/u/0/?tgif=d) и отправить в личном кабинете на проверку ссылку на ваш документ.
Название файла Google Docs должно содержать номер лекции и фамилию студента. Пример названия: "1.1. Введение в DevOps — Сусанна Алиева".

Если необходимо прикрепить дополнительные ссылки, просто добавьте их в свой Google Docs.

Перед тем как выслать ссылку, убедитесь, что ее содержимое не является приватным (открыто на комментирование всем, у кого есть ссылка), иначе преподаватель не сможет проверить работу. Чтобы это проверить, откройте ссылку в браузере в режиме инкогнито.

[Как предоставить доступ к файлам и папкам на Google Диске](https://support.google.com/docs/answer/2494822?hl=ru&co=GENIE.Platform%3DDesktop)

[Как запустить chrome в режиме инкогнито ](https://support.google.com/chrome/answer/95464?co=GENIE.Platform%3DDesktop&hl=ru)

[Как запустить  Safari в режиме инкогнито ](https://support.apple.com/ru-ru/guide/safari/ibrw1069/mac)

Любые вопросы по решению задач задавайте в чате Slack.

---
