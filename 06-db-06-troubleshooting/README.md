# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её
нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

Определение идентификатора операции/запроса, который долговыполняется (в выводе поле с именем opid)
```bash
db.currentOp()
```
Остановка запроса по его идентифкатору, полученному из предыдущей команды
```bash
db.killOp(<opId>)
```

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

1. создать индекс для ускорения выполнения запросов на чтение за счет уменьшения объема данных, которых запрос должен обработать
Методы `cursor.explain("executionStats")` и `db.collection.explain("executionStats")` предоставляют статистику производительности запроса.
Эти статистические данные могут быть полезны для измерения того, использует ли запрос индекс и каким образом.

    Например, чтобы просмотреть выбранный план запроса, используем метод `cursor.explain("executionStats")` с командой `find`:
```bash
db.inventory.find(
   { quantity: { $gte: 100, $lte: 200 } }
).explain("executionStats")
```

2. Оптимизировать запрос через его анализ и профилирование
3. Оптимизировать настройки MongoDB в контексте:
    - выделения больше оперативной памяти под хранение данных (доступных для движка `WiredTiger`)
    - использования высокоскоростных дисков (SSD или NVME) в качестве хранилища данных для ускорения операций чтения/записи

4. Использовать мониторинга, поставляемых с MongoDB(например, free monitoring), либо сторонними приложениями для мониторинга(prometheus exporter для mongodb или скрипты для zabbix-агента)

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL.
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

1.Redis удаляет 20 ключей(параметр `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP=20`) каждые 100мс,производя 10 таких циклов удаления за 1 секунду

Если в базе данных есть много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с  с установленным сроком действия, Redis может заблокироваться до тех пор,пока процент ключей, срок действия которых истек не опустится ниже 25%.

Такой подход необходим, чтобы не использовать слишком много памяти для ключей, срок действия которых уже истек

2.Второй причиной блокировки записи в Redis является заполнение всего объема оперативной памяти, который выделяется для хранения ключей(параметр `maxmemory`)

Если Redis не может удалить ключи в соответствии с политикой(параметр `maxmemory-policy`)(или установкой политики `noeviction`)
Redis начнет отвечать ошибками на команды которые будут использовать больше памяти, такие как `SET`, `LPUSH` и т. д. т.е. блокировать возможность записи в него, но при этом  продолжает отвечать на команды READ-only, такие как `GET`.



## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

1.Основной причиной разрыва соединения клиента с сервером с таким сообщением является
превышение таймаута, который отводится для передачи данных с сервера на клиент

Параметр `net_read_timeout`, который по дефолту 30 секунд

Т.к. увеличивается кол-во записей, то ответ на запрос может содержать большое количество строк, передача которых по длительности/времени превышает значение параметра `net_read_timeout`

Постепенным увеличением этого параметра подбирается значение, при котором не происходит разрыв соединения


2.Второй причиной может быть нестабильное или слишком медленное соединеия между сервером и клиентом.

Необходимо протестировать сетевую связанность на предмет
 - количество потери пакетов
 - время ответа (rounr trip time)

3.Третьей причиной может быть слишком медленное подключение клиента к серверу, которое превышает установленный параметром `connect_timeout` таймаут в несколько секунд

Можно отследить кол-во таких прерванных соединений через одно из значений/параметров состояния MySQL(`Aborted_connects`)
`SHOW GLOBAL STATUS LIKE 'Aborted_connects'`

Однако причиной роста этого значения могут быть и другие причины(клиент не имеет достаточно привиллегиий для подключения, пароль подключения некорректный, пакет подклчючения не валиден(не содержит правильные данные), некорректное отключение клиента после его успешного подключения)

4.Четвертой причиной возможен большой запрос с типом  BLOB, размер которого больше чем установленный параметром `max_allowed_packet`

Увеличение значение параметра `max_allowed_packet` позволит устранить разрыв соединения между сервером и клиентом




## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?


`OOM (Out of memory) Killer` - процесс, который удаляет один или несколько запущенных процессов с целью освобождения оперативной памяти, когда операционной системе ее не хватает для выделения на вновь создаваемые процессы

Это необходимо для того,чтобы защитить ядро от паники (`kernel panic`)

Когда принудительно завершается процесс PostgreSQL, в логе появляется указанное в задании сообщение

Решения:
1. Установление процессов, которые используют много оперативной памяти, их оптимизация на предмет уменьшения потребляемой оперативной памяти.
2. Если это сервер только для PostgreSQL,тогда:
    - оптимизировать запросы
    - установить размер, который postgres может использовать для загрузки данных в оперативную память
3. Увеличить размер оперативной памяти на сервере или включить SWAP-подкачку, если  в качестве хранилища используются высокоскоростные диски (SSD/NVME)(чтобы просадка производиельноости по чтению/записи была минимальной, а она будет т.к. работа с дисками будет медленне,чем работа с памятью)
4. Настроить OOM-Killer на не убивание PostgreSQL-процесса за счет повышения его приоритета