# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`.

    Cистемный вызов `chdir`
    `chdir("/tmp")`

1. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:
    ```bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ```
    Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.

    ```bash
    $ strace file /dev/sda
    openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
    openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
    ```
    База данных `file` находится в файле `/usr/share/misc/magic.mgc`,
    который в свою очередь является символьной ссылкой на файл `/usr/lib/file/magic.mgc`
    ```bash
    $ ls -al  /usr/share/misc/ | grep magic
    lrwxrwxrwx   1 root root      13 мар 21  2020 magic -> ../file/magic
    lrwxrwxrwx   1 root root      24 мая 12  2020 magic.mgc -> ../../lib/file/magic.mgc
    ```

1. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

   - Узнаем идентификатор процесса `pid`, который пишит в удаленный файл
   - Через lsof или proc (`ls -al /proc/$pid/fd/`)узнаем файловый дескриптор, который имеется у удаленного файла
   - Очищаем содержимое удаленного файла через его файловый дескриптор

   Например

   Идентифкатор процесса, который пишит в удаленный файл
   ```bash
   $ pgrep skypeforlinux
   9748
   ```

   файловый дескриптор, который имеется у удаленного файла - 57

   Размер фала 16 байт

   ```bash
   $ lsof -p 9748 | grep '(deleted)|SIZE'
   COMMAND    PID   USER   FD      TYPE             DEVICE  SIZE/OFF    NODE NAME
   skypeforl 9748 eugene   57u      REG                8,7        16 1310838 /tmp/skype-9748/skypert_sessionkey1ZXsIm (deleted)
   ```

   Очищаем содержимое удаленного файла через файловый дескриптор удаленного файла и проверяем его нулевой размер
   ```bash
   $ :> "/proc/9748/fd/57"
   ```
   ```bash
   $ lsof -p 9748 | grep '(deleted)|SIZE'
   COMMAND    PID   USER   FD      TYPE             DEVICE  SIZE/OFF    NODE NAME
   skypeforl 9748 eugene   57u      REG                8,7         0 1310838 /tmp/skype-9748/skypert_sessionkey1ZXsIm (deleted)
   ```



1. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

    Нет, зомби процесс - это процесс, который уже завершил свое выполнение, но по какой-либо причине
    родительский процесс не обработал код возврата дочернего процесса, в результате чего такой дочерний процесс
    становится зомби-процессом и присутствует в списке процессов в операционной системе не потребляя никаких ресурсов т.к. по факту это процесс        уже был выполнен

1. В iovisor BCC есть утилита `opensnoop`:
    ```bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```
    На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).

    ```bash
    $ apt-get install bpfcc-tools
    ```

    ```bash
    $ dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```

    ```bash
    $ strace  -e openat opensnoop-bpfcc > out.txt 2>&1
    ```

    ```bash
    $ cat open out.txt
    execve("/usr/sbin/opensnoop-bpfcc", ["opensnoop-bpfcc"], 0x7ffea352afb0 /* 16 vars */) = 0
    openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libutil.so.1", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libexpat.so.1", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libz.so.1", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", O_RDONLY) = 3
    openat(AT_FDCWD, "/usr/bin/pyvenv.cfg", O_RDONLY) = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/usr/pyvenv.cfg", O_RDONLY) = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/etc/localtime", O_RDONLY|O_CLOEXEC) = 3
    openat(AT_FDCWD, "/usr/lib/python3.8", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
    .....
    ```
1. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.


    ```bash
    $ strace uname -a
    ```

    ```bash
    uname({sysname="Linux", nodename="vagrant", ...}) = 0
    uname({sysname="Linux", nodename="vagrant", ...}) = 0
    write(1, "Linux vagrant 5.4.0-80-generic #"..., 105Linux vagrant 5.4.0-80-generic #90-Ubuntu SMP Fri Jul 9 22:49:44 UTC 2021 x86_64 x86_64     x86_64 GNU/Linux
    ) = 105
    ```

    Системный вызов `uname`

    ```bash
    $ apt-get install manpages-dev
    ```
    ```bash
    $ man 2 uname | grep /proc
           Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
    ```
    ```bash
    $ cat /proc/sys/kernel/hostname
    vagrant
    $ cat /proc/sys/kernel/osrelease
    5.4.0-80-generic
    $ cat /proc/sys/kernel/version
    #90-Ubuntu SMP Fri Jul 9 22:49:44 UTC 2021
    $ cat /proc/sys/kernel/domainname
    (none)
    ```
1. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    Есть ли смысл использовать в bash `&&`, если применить `set -e`?


     - последовательность команд через `;`

    Команды будут выполнены последовательно независимо от кода возврата/выхода предыдущей команды
    т.е. сначало выполнится команда  `test -d /tmp/some_dir` с кодом возврата 1 т.к. каталога `/tmp/some_dir` не существует
    Затем выполнится команда `echo Hi`

    - последовательность команд через `&&`

    `&&` - выполнить логическую операцию `И`
    Сначало выполняется первая команда, а вторая команда будет выполняться только в том случае, если первая команда
    завершилась успешно
    т.е сначало выполнится команду `test -d /tmp/some_dir` с кодом возврата 1 т.к. каталога `/tmp/some_dir` не существует, поэтому
    команда `echo Hi` выполняться не будет



    Set позволяет управлять параметрами оболочки и командной строки

    Параметр `-e (errexit)` приводит к прекращению выполнения ВСЕХ дальнейших команд и немедленному выходу
    если текущая команда выполнилась с кодом выхода отличным от нуля

    А конструкция `&&` позволяет не выполнять следующую команду, если предыдущая завершилась с кодом выхода отличным от нуля
    При этом все остальные команды, которые не следуют за конструкцией `&&` могут/будут выполняться

    т.е. если, например, в скрипте есть несколько команд и необходимо сразу прекращать выполнение скрипта,если завершение какой-либо команды
    было неуспешным (не с нулевым кодом возврата/завершения), то тогда нужно использовать опцию `-e(errexit)` через установку
    в начале скрипта этого параметра с помощью
    `set -e`

    Если же в таком же скрипте одна из команда не должна выполняться,если предыдущая выполнилась некорректно,
    но при этом нужно продолжать выполнение остальных команд, тогда нужно использовать конструкцию `&&`

    При этом если глобально( в самом начале скрипта) установлен флаг `-e` его можно отключить для команды(в данном случае команды command 3), чье неуспешное завершение приводит к тому, что следующая команда не выполнится, но при этом продолжится выполнение дальнейших команд в  скрипте

    ```bash
    #!/usr/bin/env bash
    set -e
    command 1
    command 2
    set +e
    command 3 && command4
    set -e
    command5
    ```

1. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?


    `-e(errexit)` - прекращение выполнения ВСЕХ дальнейших команд и немедленный выход со скрипта, если текущая команда выполнилась с кодом выхода отличным от нуля.

    Полезно, когда нужно прерать дальнейшее выполнение команд/скрипта, если зафейлилась предыдущая команда

    `-u(nounset)` - Интерпретировать при подстановках неустановленные переменные и параметры, как ошибки (кроме специальных переменных `$@` и `$*`)
    т.е. при попытке подставить неопределенную переменную или параметр, интерпретатор bash выведет сообщение об ошибке и прекратит дальнейшее
    выполнение команд/скрипта.

    Полезно, чтобы выполнять команды с гарантированно установленными переменными/параметрами

    Например, чтобы не получилось `rm -rf /etc/${NON_SETUP_VARIABLE}` и при неустановленной переменной `NON_SETUP_VARIABLE`
    ее значение ожидаемо подставится в пустое значение/null в результате чего получится `rm -rf /etc/`, что приведет к удалению каталога `/etc` , а это явно не то, что задумывалось.


    `-x(xtrace)` - отображать команды вместе с их аргументами, когда они выполняются.

    Это обеспечивает пошаговую трассировку выполнения команд.

    Полезно для дебага выполнения команд.

    `-o` - активирует заданный режим работы

    В данном случае активирует режим работы `pipefail`,который
    заменяет код возврата всего конвеера(pipeline) на код возврата последней неудачно завершившейся команды
    или нулевой код возврата, если все команды в конвеере завершились успешно.

    Полезно, если нужно отслеживать код выполнения всего конвеера команд с целью выполнения какой-либо логики, если одна из команд в
    конвеере выполнилась неуспешно.

1. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

    С учетом того, что состояние процесса определяется его первой буквой, то наиболее часто встречающийся статус у процессов в системе является     статус `Sleep` (S)

    ```bash
     $ ps -ax -o stat | sort | uniq -c | sort -rn
         53 Sl+
         45 I<
         41 S
         38 Ssl
         38 S<
         19 Sl
         18 Ss
         15 I
         11 S+
          4 SLl+
          4 SLl
          2 SN
          2 Rl+
          2 D
          1 STAT
          1 Ssl+
          1 Ss+
          1 S<s
          1 SNsl
          1 S<l
          1 R+
          1 Dsl
    ```

    Также можно использовать опцию `state`, чтобы вывести процессы с одной буквой в их состояниии:

    ```bash
    $ ps -ax -o state | sort | uniq -c | sort -rn
        235 S
         59 I
          4 D
          2 R
    ```

    `<` - процесс с высоким приоритетом

    `N` -  процесс с низким приоритетом

    `L` - процес имеет страницы заблокированные в памяти

    `s` - лидер сессии/сеанса

    `l` - многопоточный процесс  (с использованием CLONE_THREAD)

    `+` - процесс запущен/находится в группе процессов, который запущены на переднем плане(foreground)
